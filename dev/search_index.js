var documenterSearchIndex = {"docs":
[{"location":"api/#API-Documentation","page":"API","title":"API Documentation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = Lerche","category":"page"},{"location":"api/#Parsing","page":"API","title":"Parsing","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"A parser is created from a Lark grammar by calling the Lark constructor. Parsing is initiated by calling parse.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Lark(grammar::String;options...)\nLark(grammar::IOStream,source;options...)\nLerche.open(grammar_filename;rel_to=nothing,options...)\nLerche.parse(l::Lark,text;start=nothing,on_error=nothing)\nUnexpectedCharacters\nUnexpectedToken","category":"page"},{"location":"api/#Lerche.Lark-Tuple{String}","page":"API","title":"Lerche.Lark","text":"Lark(grammar::String;options...)\n\nCreate a Lark parser based on the Lark grammar expressed in grammar. Options are as follows:\n\nparser Decides which parser engine to use, \"earley\" or \"lalr\". (Default: \"lalr\")      Note: \"lalr\" requires a lexer. \"earley\" is not currently implemented.\nlexer Decides whether or not to use a lexer stage\n\"standard\": Use a standard lexer\n\"contextual\": Stronger lexer (only works with parser=\"lalr\")\n\"auto\" (default): Choose for me based on grammar and parser\ntransformer - Applies the transformer to every parse tree\ndebug - Affects verbosity (default: False)\nkeep_all_tokens - Don't automagically remove \"punctuation\" tokens (default: False)\npostlex - Lexer post-processing (Requires standard lexer. Default: None)\nstart - The start symbol (Default: start)\npropagate_positions - Propagates [line, column, end line, end column] attributes into all tree branches.\nlexer_callbacks - Dictionary of callbacks for the lexer. May alter tokens during lexing. Use with caution.\n\n\n\n\n\n","category":"method"},{"location":"api/#Lerche.Lark-Tuple{IOStream, Any}","page":"API","title":"Lerche.Lark","text":"Lark(grammar::IOStream,source;options...)\n\nCreate a Lark parser based on the Lark grammar found by reading grammar, whose source is recorded as source. See above for options.\n\n\n\n\n\n","category":"method"},{"location":"api/#Lerche.open-Tuple{Any}","page":"API","title":"Lerche.open","text":"open(grammar_filename;rel_to=nothing,options...)\n\nOpen grammar_filename and read in a Lark grammar, returning a Lark parser. If rel_to is not nothing, grammar_filename is relative to rel_to. Options are the same as for Lark(grammar::String;options...).\n\n\n\n\n\n","category":"method"},{"location":"api/#Lerche.parse-Tuple{Lark, Any}","page":"API","title":"Lerche.parse","text":"parse(l::Lark,text;start=nothing,on_error=nothing)\n\nParse text using parser l, returning a parse tree. If start is not nothing, it identifies the start symbol. on_error is currently ignored.\n\nIf text does not conform to the grammar, either  UnexpectedToken or UnexpectedCharacters  is raised.\n\n\n\n\n\n","category":"method"},{"location":"api/#Lerche.UnexpectedCharacters","page":"API","title":"Lerche.UnexpectedCharacters","text":"UnexpectedCharacters\n\nThis exception is raised when the next characters in the input stream cannot be matched with any acceptable tokens.\n\n\n\n\n\n","category":"type"},{"location":"api/#Lerche.UnexpectedToken","page":"API","title":"Lerche.UnexpectedToken","text":"UnexpectedToken\n\nThis exception is raised when a token is encountered in the input stream that is not allowed by the grammar.\n\n\n\n\n\n","category":"type"},{"location":"api/#Working-with-the-parse-tree","page":"API","title":"Working with the parse tree","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"transform transforms the parse tree according to rules defined by the user using @rule and @inline_rule macros. Tokens will also be processed using methods defined using @terminal if visit_tokens  returns true for that transformer type. Token processing will slow down parse tree processing by around 20%.","category":"page"},{"location":"api/","page":"API","title":"API","text":"@rule s\n@inline_rule s\n@terminal s\nTransformer\nTransformer_InPlace\nTransformer_InPlaceRecursive\nvisit_tokens(t::Transformer)\ntransform(tr::Transformer,tree)\nVisitor\nVisitor_Recursive\nInterpreter\nvisit(v::Visitor,tree)","category":"page"},{"location":"api/#Lerche.@rule-Tuple{Any}","page":"API","title":"Lerche.@rule","text":"@rule s\n\ns is a function rule_name(t,args) where t is an instance of a subtype of Transformer or Visitor. args is an array holding values for each node of the grammar production.\n\n\n\n\n\n","category":"macro"},{"location":"api/#Lerche.@inline_rule-Tuple{Any}","page":"API","title":"Lerche.@inline_rule","text":"@inline_rule s\n\ns is a function of the form rule_name(t,args...) where rule_name is the name of a grammar rule and args are values for the individual elements of that rule's grammar production. This rule is called by transform(t,tree) and visit(v,tree). t is a subtype of Transformer and v is a subtype of Visitor.\n\n\n\n\n\n","category":"macro"},{"location":"api/#Lerche.@terminal-Tuple{Any}","page":"API","title":"Lerche.@terminal","text":"@terminal s\n\ns is a function definition of form terminal_name(t,tok) = ... where t is an instance of a subtype of Transformer or Visitor. tok is a token of type terminal_name. If visit_tokens(::t) is true, this function will be called whenever tokens of type terminal_name are processed.\n\n\n\n\n\n","category":"macro"},{"location":"api/#Lerche.Transformer","page":"API","title":"Lerche.Transformer","text":"Transformers visit each node of the tree, and run the appropriate method on it according to the node's data.\n\nThe methods (provided by the user) are dispatched according to the type and the node's grammar rule. The returned value replaces the old one in the structure.\n\nThey work bottom-up (or depth-first), starting with the leaves and ending at the root of the tree.  Transformers can be used to implement map - reduce patterns. Because nodes are reduced from leaf to root, at any point the callbacks may assume the children have already been transformed (if applicable).\n\nTransformer can do anything Visitor can do, but because it reconstructs the tree, it is slightly less efficient.\n\nNOTE: A transformer without methods essentially performs a non-memoized deepcopy.\n\n\n\n\n\n","category":"type"},{"location":"api/#Lerche.Transformer_InPlace","page":"API","title":"Lerche.Transformer_InPlace","text":"Transformer_InPlace\n\nNon-recursive Transformer. Changes the tree in-place instead of returning new instances\n\n\n\n\n\n","category":"type"},{"location":"api/#Lerche.Transformer_InPlaceRecursive","page":"API","title":"Lerche.Transformer_InPlaceRecursive","text":"Transformer_InPlaceRecursive\n\nRecursive. Changes the tree in-place instead of returning new instances.\n\n\n\n\n\n","category":"type"},{"location":"api/#Lerche.visit_tokens-Tuple{Transformer}","page":"API","title":"Lerche.visit_tokens","text":"visit_tokens(t::Transformer)\n\nShould the transformer visit tokens in addition to rules.  Setting this to false is an order of magnitude faster. For consistency with Lark Defaults to true.  (For processing ignored tokens, use the lexer_callbacks options)\n\n\n\n\n\n","category":"method"},{"location":"api/#Lerche.transform-Tuple{Transformer, Any}","page":"API","title":"Lerche.transform","text":"transform(tr::Transformer,tree)\n\nTransform parse tree tree according to rules defined for type tr. Typically tr is a subtype of Transformer.\n\n\n\n\n\n","category":"method"},{"location":"api/#Lerche.Visitor","page":"API","title":"Lerche.Visitor","text":"Visitor\n\nUser-defined methods called with an instance of a subtype of Visitor will visit each node of the parse tree in top-down order without altering it or returning  a transformed tree.\n\n\n\n\n\n","category":"type"},{"location":"api/#Lerche.Visitor_Recursive","page":"API","title":"Lerche.Visitor_Recursive","text":"When called by `visit`, subtypes of `Visitor_Recursive` visit nodes of the parse tree\nin bottom-up order.\n\n\n\n\n\n","category":"type"},{"location":"api/#Lerche.Interpreter","page":"API","title":"Lerche.Interpreter","text":"Subtypes of the `Interpreter` type do not automatically visit children\nof the parse tree node when called by `visit`.\n\n\n\n\n\n","category":"type"},{"location":"api/#Lerche.visit-Tuple{Visitor, Any}","page":"API","title":"Lerche.visit","text":"visit(v::Visitor,tree)\n\nVisit each node of tree, calling methods defined for v on each node.\n\n\n\n\n\n","category":"method"},{"location":"#Introduction:-Lerche.jl","page":"Overview and Guide","title":"Introduction: Lerche.jl","text":"","category":"section"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"Lerche.jl creates a parser for a language specified in an EBNF-like syntax. The resulting parse trees can be transformed using easy-to-specify methods, where Lerche.jl takes care of the parse tree traversal. Lerche.jl is a direct translation of the Python-language Lark parser generator (Lerche is \"Lark\" in German).","category":"page"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"Much of the extensive Lark documentation is also relevant.","category":"page"},{"location":"#Quick-start","page":"Overview and Guide","title":"Quick start","text":"","category":"section"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"If you are already familiar with Lark see  Notes for Lark users below.","category":"page"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"Lerche reads EBNF grammars as recognised by Lark (\"Lark grammars\") to produce a parser. This parser, when provided with text conforming to the grammar, produces a parse tree. This tree can be visited and transformed using \"rules\". A rule is a function named after the production whose arguments it should be called on, and the first argument of a rule is an object which is a subtype of Visitor or Transformer.","category":"page"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"Given an EBNF grammar, it can be used to parse text into your data structure as follows:","category":"page"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"Define one or more subtypes of Transformer or Visitor, instances of which will be passed as the first argument to the appropriate rule.  The instance can also be used to hold information during transformation if you wish, in which case it must have a concrete type.\nDefine visit_tokens(t::MyNewType) = false if you will not be processing token values. This is about 25% faster than leaving the default true.\nFor every production in your grammar that you wish to process, write a rule with identical name to the production\nThe rule should be prefixed with macro @rule if the second argument is an array containing all of the arguments to the grammar production\nThe rule should be prefixed with macro @inline_rule if the second and following arguments refer to each argument in the grammar production\nFor every token which you wish to process, define an identically-named method as for rules, but precede it with a @terminal macro instead of @rule.","category":"page"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"If your grammar is in String variable mygrammar, your text to be parsed and transformed is in String variable mytext, and your Transformer subtype is MyTransformer, the following commands will produce a data structure from the text:","category":"page"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"p = Lark(mygrammar,parser=\"lalr\",lexer=\"contextual\") #create parser\nt = Lerche.parse(p,mytext)     #Create parse tree\nx = Lerche.transform(MyTransformer(),t)  #transform parse tree","category":"page"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"For a real-world example of usage, see this file.","category":"page"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"tip: Tip\nFully qualify the parse call (i.e. write Lerche.parse) to avoid ambiguity with parse from other packages, including Base.parse","category":"page"},{"location":"#Error-handling","page":"Overview and Guide","title":"Error handling","text":"","category":"section"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"When the supplied text does not match the grammar, parse raises exceptions that are subtypes of UnexpectedInput:UnexpectedToken and UnexpectedCharacters. Base.show for these types produces an informative message regarding the position of the error and expected tokens.","category":"page"},{"location":"#Defining-a-Grammar","page":"Overview and Guide","title":"Defining a Grammar","text":"","category":"section"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"The full Lark grammar is described here.","category":"page"},{"location":"#Example","page":"Overview and Guide","title":"Example","text":"","category":"section"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"The following example (condensed from the JSON example in Lark ) how a simple JSON parser is implemented.","category":"page"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"using Lerche","category":"page"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"First, the grammar:","category":"page"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"json_grammar = raw\"\"\"\n    ?start: value\n\n    ?value: object\n          | array\n          | string\n          | SIGNED_NUMBER      -> number\n          | \"true\"             -> t\n          | \"false\"            -> f\n          | \"null\"             -> null\n\n    array  : \"[\" [value (\",\" value)*] \"]\"\n    object : \"{\" [pair (\",\" pair)*] \"}\"\n    pair   : string \":\" value\n\n    string : ESCAPED_STRING\n\n    %import common.ESCAPED_STRING\n    %import common.SIGNED_NUMBER\n    %import common.WS\n\n    %ignore WS\n\"\"\";","category":"page"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"Note that terminals are always uppercase, and common definitions can be imported from definitions in the standard library supplied with Lerche.","category":"page"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"A method whose name matches the rule name (or alias) and whose first argument has our subtype of Transformer will be called whenever that rule is matched.","category":"page"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"These methods are prefixed by the @rule macro (if all of the parse tree children are collected into a single array argument) or @inline_rule macro (if each parse tree child is assigned a separate argument). ","category":"page"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"\nstruct TreeToJson <: Transformer end\n\n@inline_rule string(t::TreeToJson, s) = replace(s[2:end-1],\"\\\\\\\"\"=>\"\\\"\")\n\n@rule  array(t::TreeToJson,a) = Array(a)\n@rule  pair(t::TreeToJson,p) = Tuple(p)\n@rule  object(t::TreeToJson,o) = Dict(o)\n@inline_rule number(t::TreeToJson,n) = Base.parse(Float64,n)\n\n@rule  null(t::TreeToJson,_) = nothing\n@rule  t(t::TreeToJson,_) = true\n@rule  f(t::TreeToJson,_) = false","category":"page"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"The above rules define a TreeToJson subtype of Transformer, and rules whose names match the rule or alias names in the grammar. For example, whenever the string rule is matched, the enclosing double quotes are dropped and any \\\" sequences replaced by a double quote.","category":"page"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"Finally, we create our parser by calling the Lark constructor:","category":"page"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"json_parser = Lark(json_grammar, parser=\"lalr\", lexer=\"standard\", transformer=TreeToJson());","category":"page"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"Passing the transformer argument at parser construction time avoids a separate call to the transform method after parsing.","category":"page"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"Now, we can parse JSON by calling the Lerche.parse method with json_parser as the first argument and the text to parse as the second argument:","category":"page"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"text = raw\"{\\\"key\\\": [\\\"item0\\\", \\\"item1\\\", 3.14]}\"\nj = Lerche.parse(json_parser,text)","category":"page"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"The above example is available in the Examples directory for study.","category":"page"},{"location":"#Other-examples","page":"Overview and Guide","title":"Other examples","text":"","category":"section"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"The tests directory contains many more very simple examples of correctly-constructed grammars.","category":"page"},{"location":"#Notes-for-Lark-users","page":"Overview and Guide","title":"Notes for Lark users","text":"","category":"section"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"When converting from Lark programs written in Python to Lerche programs written in Julia, make the following changes:","category":"page"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"All Transformer and Visitor classes become types  \nAll class method calls become Julia method calls with an instance of the type as the first argument (i.e. replacing self)\nTransformation or visitor rules should be preceded by the @rule macro. Inline rules use the @inline_rule macro and token processing methods use @terminal. \nAny grammars containing backslash-double quote sequences need to be edited (see below).\nAny grammars containing backslash-x to denote a byte value need to be edited (see below).","category":"page"},{"location":"#Grammars","page":"Overview and Guide","title":"Grammars","text":"","category":"section"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"Lark grammars work unchanged in Lerche, with the caveats below.  Note that this guarantee applies to the sequence of characters after interpretation by the Julia or Python language parser.  In particular note the following differences:","category":"page"},{"location":"","page":"Overview and Guide","title":"Overview and Guide","text":"Raw strings in Julia are written raw\"<string contents>\" instead of Python's r\"<string contents>\"\nThe sequence \\\" inside a Python raw, quote-delimited string encodes a two-character sequence.  However, it corresponds to a single quote in Julia. To obtain the two-character sequence in Julia, write \\\\\". Such a backslash-quote sequence is required in Lark grammars to represent a double quote, just like in Python; so these two characters must remain in the string after Julia has pre-processed it.\nWhile unicode escapes are recognised (\\uxxxx), the Python \\x combination to insert a particular byte value in the string is not. Simply replace with the appropriate Unicode character.","category":"page"},{"location":"grammar/#Grammar-Reference","page":"Grammar reference","title":"Grammar Reference","text":"","category":"section"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Lerche.jl reads grammars in a syntax developed for the Python Lark system.  These are referred to as \"Lark grammars\" below. The following information is adapted from the grammar reference provided with Lark.","category":"page"},{"location":"grammar/#Definitions","page":"Grammar reference","title":"Definitions","text":"","category":"section"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"A grammar is a list of rules and terminals, that together define a language.","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Terminals define the alphabet of the language, while rules define its structure.","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"In Lerche, a terminal may be a string, a regular expression, or a concatenation of these and other terminals.","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Each rule is a list of terminals and rules, whose location and nesting define the structure of the resulting parse-tree.","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"A parsing algorithm is an algorithm that takes a grammar definition and a sequence of symbols (members of the alphabet), and matches the entirety of the sequence by searching for a structure that is allowed by the grammar.","category":"page"},{"location":"grammar/#General-Syntax-and-notes","page":"Grammar reference","title":"General Syntax and notes","text":"","category":"section"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Lark grammars are based on EBNF syntax, with several enhancements.","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"EBNF is basically a short-hand for common BNF patterns.","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Optionals are expanded:","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"  a b? c    ->    (a c | a b c)","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Repetition is extracted into a recursion:","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"  a: b*    ->    a: _b_tag\n                 _b_tag: (_b_tag b)?","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"And so on.","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Lark grammars are composed of a list of definitions and directives, each on its own line. A definition is either a named rule, or a named terminal, with the following syntax, respectively:","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"  rule: <EBNF EXPRESSION>\n      | etc.\n\n  TERM: <EBNF EXPRESSION>   // Rules aren't allowed","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Comments start with // and last to the end of the line (C++ style)","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Lerche begins the parse with the rule 'start', unless specified otherwise in the options.","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Names of rules are always in lowercase, while names of terminals are always in uppercase. This distinction has practical effects, for the shape of the generated parse-tree, and the automatic construction of the lexer (aka tokenizer, or scanner).","category":"page"},{"location":"grammar/#Terminals","page":"Grammar reference","title":"Terminals","text":"","category":"section"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Terminals are used to match text into symbols. They can be defined as a combination of literals and other terminals.","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Syntax:","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"<NAME> [. <priority>] : <literals-and-or-terminals>","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Terminal names must be uppercase.","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Literals can be one of:","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"\"string\"\n/regular expression+/\n\"case-insensitive string\"i\n/re with flags/imulx\nLiteral range: \"a\"..\"z\", \"1\"..\"9\", etc.","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Terminals also support grammar operators, such as |, +, * and ?.","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Terminals are a linear construct, and therefore may not contain themselves (recursion isn't allowed).","category":"page"},{"location":"grammar/#Templates","page":"Grammar reference","title":"Templates","text":"","category":"section"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Templates are expanded when preprocessing the grammar.","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Definition syntax:","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"  my_template{param1, param2, ...}: <EBNF EXPRESSION>","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Use syntax:","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"some_rule: my_template{arg1, arg2, ...}","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Example:","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"_separated{x, sep}: x (sep x)*  // Define a sequence of 'x sep x sep x ...'\n\nnum_list: \"[\" _separated{NUMBER, \",\"} \"]\"   // Will match \"[1, 2, 3]\" etc.","category":"page"},{"location":"grammar/#Priority","page":"Grammar reference","title":"Priority","text":"","category":"section"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Terminals can be assigned priority only when using a lexer (future versions may support Earley's dynamic lexing).","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Priority can be either positive or negative. If not specified for a terminal, it defaults to 1.","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Highest priority terminals are always matched first.","category":"page"},{"location":"grammar/#Regexp-Flags","page":"Grammar reference","title":"Regexp Flags","text":"","category":"section"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"You can use flags on regexps and strings. For example:","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"SELECT: \"select\"i     //# Will ignore case, and match SELECT or Select, etc.\nMULTILINE_TEXT: /.+/s\nSIGNED_INTEGER: /\n    [+-]?  # the sign\n    (0|[1-9][0-9]*)  # the digits\n /x","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Supported flags are one of: imslux. See Julia's regex documentation for more details on each one.","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Regexps/strings of different flags may not be concatenated.","category":"page"},{"location":"grammar/#Notes-for-using-a-lexer","page":"Grammar reference","title":"Notes for using a lexer","text":"","category":"section"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"When using a lexer (standard or contextual), it is the grammar-author's responsibility to make sure the literals don't collide, or that if they do, they are matched in the desired order. Literals are matched according to the following precedence:","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Highest priority first (priority is specified as: TERM.number: ...)\nLength of match (for regexps, an estimate of longest theoretical match is used)\nLength of literal / pattern definition\nName","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Examples:","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"IF: \"if\"\nINTEGER : /[0-9]+/\nINTEGER2 : (\"0\"..\"9\")+          //# Same as INTEGER\nDECIMAL.2: INTEGER? \".\" INTEGER  //# Will be matched before INTEGER\nWHITESPACE: (\" \" | /\\t/ )+\nSQL_SELECT: \"select\"i","category":"page"},{"location":"grammar/#Regular-expressions-and-Ambiguity","page":"Grammar reference","title":"Regular expressions & Ambiguity","text":"","category":"section"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Each terminal is eventually compiled to a regular expression. All the operators and references inside it are mapped to their respective expressions.","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"For example, in the following grammar, A1 and A2, are equivalent:","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"A1: \"a\" | \"b\"\nA2: /a|b/","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"This means that inside terminals, Lerche.jl cannot detect or resolve ambiguity.","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"For example, for this grammar:","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"start           : (A | B)+\nA               : \"a\" | \"ab\"\nB               : \"b\"","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"We get this behavior:","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":">>> parse(p, \"ab\")\nTree(start, [Token(A, \"a\"), Token(B, \"b\")])","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"This is happening because the regex engine always returns the first matching option.","category":"page"},{"location":"grammar/#Rules","page":"Grammar reference","title":"Rules","text":"","category":"section"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Syntax:","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"<name> : <items-to-match>  [-> <alias> ]\n       | ...","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Names of rules and aliases are always in lowercase.","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Rule definitions can be extended to the next line by using the OR operator (signified by a pipe: | ).","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"An alias is a name for the specific rule alternative. It affects tree construction.","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Each item is one of:","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"rule\nTERMINAL\n\"string literal\" or /regexp literal/\n(item item ..) - Group items\n[item item ..] - Maybe. Same as (item item ..)?, but when maybe_placeholders=True, generates nothing if there is no match.\nitem? - Zero or one instances of item (\"maybe\")\nitem* - Zero or more instances of item\nitem+ - One or more instances of item\nitem ~ n - Exactly n instances of item\nitem ~ n..m - Between n to m instances of item (not recommended for wide ranges, due to performance issues)","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Examples:","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"hello_world: \"hello\" \"world\"\nmul: (mul \"*\")? number     //# Left-recursion is allowed and encouraged!\nexpr: expr operator expr\n    | value               //# Multi-line, belongs to expr\n\nfour_words: word ~ 4","category":"page"},{"location":"grammar/#Priority-2","page":"Grammar reference","title":"Priority","text":"","category":"section"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Rules can be assigned priority only when using Earley (future versions may support LALR as well).","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Priority can be either positive or negative. In not specified for a terminal, it's assumed to be 1 (i.e. the default).","category":"page"},{"location":"grammar/#Directives","page":"Grammar reference","title":"Directives","text":"","category":"section"},{"location":"grammar/#%ignore","page":"Grammar reference","title":"%ignore","text":"","category":"section"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"All occurrences of the terminal will be ignored, and won't be part of the parse.","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Using the %ignore directive results in a cleaner grammar.","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"It's especially important for the LALR(1) algorithm, because adding whitespace (or comments, or other extraneous elements) explicitly in the grammar, harms its predictive abilities, which are based on a lookahead of 1.","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Syntax:","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"%ignore <TERMINAL>","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Examples:","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"%ignore \" \"\n\nCOMMENT: \"#\" /[^\\n]/*\n%ignore COMMENT","category":"page"},{"location":"grammar/#%import","page":"Grammar reference","title":"%import","text":"","category":"section"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Allows one to import terminals and rules from lark grammars.","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"When importing rules, all their dependencies will be imported into a namespace, to avoid collisions. It's not possible to override their dependencies (e.g. like you would when inheriting a class).","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Syntax:","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"%import <module>.<TERMINAL>\n%import <module>.<rule>\n%import <module>.<TERMINAL> -> <NEWTERMINAL>\n%import <module>.<rule> -> <newrule>\n%import <module> (<TERM1>, <TERM2>, <rule1>, <rule2>)","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"If the module path is absolute, Lerche will attempt to load it from the built-in directory (which currently contains common.lark).","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"If the module path is relative, such as .path.to.file, Lark will attempt to load it from the current working directory. Grammars must have the .lark extension.","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"The rule or terminal can be imported under another name with the -> syntax.","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Example:","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"%import common.NUMBER\n\n%import .terminals_file (A, B, C)\n\n%import .rules_file.rulea -> ruleb","category":"page"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Note that %ignore directives cannot be imported. Imported rules will abide by the %ignore directives declared in the main grammar.","category":"page"},{"location":"grammar/#%declare","page":"Grammar reference","title":"%declare","text":"","category":"section"},{"location":"grammar/","page":"Grammar reference","title":"Grammar reference","text":"Declare a terminal without defining it. Useful for plugins.","category":"page"}]
}
